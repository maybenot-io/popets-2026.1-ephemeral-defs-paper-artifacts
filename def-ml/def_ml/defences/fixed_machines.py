from __future__ import annotations

import os
import tempfile
from abc import abstractmethod
from pathlib import Path

import dotenv
import torch
import yaml
from mbnt import sim_trace_from_file_advanced

from def_ml.data.utils import parse_trace_to_tensor_dict
from def_ml.defences.base import DEFENCE_TYPE_KW, _Def
from def_ml.logging.logger import get_logger
from def_ml.logging.utils import log_multiline
from def_ml.tools.rng_samplers import MachineRng
from def_ml.trace.params import EVENTS_MULTIPLIER, MAX_TRACE_LENGTH

dotenv.load_dotenv()

logger = get_logger(__name__)


def load_machines(
    deck_path: os.PathLike, machine_idxs: list[int] | None = None
) -> list[dict[str, list[str]]]:
    logger.info("Loading machines from: %s", deck_path)
    with open(deck_path, "r", encoding="utf-8") as fi:
        cmd = fi.readline().replace("\n", "")
        logger.info(f"Generated by: {cmd}")

        line = fi.readline()
        defenses = []
        while line != "":
            defenses.append(yaml.safe_load(line))
            line = fi.readline()

    machine_idxs = machine_idxs or list(range(len(defenses)))

    if max(machine_idxs) >= len(defenses):
        raise ValueError(
            f"Machine idxs out of bounds: {max(machine_idxs)} >= {len(defenses)}"
        )

    return [d for i, d in enumerate(defenses) if i in machine_idxs]


class _FixedMachine(_Def):

    def __init__(
        self,
        network_delay_millis: tuple[int, int],
        network_pps: tuple[int, int],
        seed: int | None = 42,
        fixed_per_trace: bool = False,
        simul_kwargs: dict | None = None,
    ):
        if (MACHINATION := os.getenv("MAYBENOT")) is None:
            raise ValueError("machination not found in environment")

        super().__init__(
            network_delay_millis=network_delay_millis,
            network_pps=network_pps,
            seed=seed,
            fixed_per_trace=fixed_per_trace,
        )

        self._rust_machination = MACHINATION
        tmpfile_ = tempfile.mktemp(prefix=self.__class__.__name__, suffix=".defence")

        if not hasattr(self, "machination_kwargs"):
            raise AttributeError(
                "Subclass must define 'machination_kwargs' before calling super().__init__()"
            )
        self.machination_args = None
        self._machination(tmpfile_, **self.machination_kwargs)
        self.machines = load_machines(Path(tmpfile_))
        self.machine_rng = MachineRng(len(self.machines))

        os.remove(tmpfile_)

        self.simul_kwargs = {} or simul_kwargs

    def report(self, to_log: bool = False) -> str:

        str_ = self.__class__.__name__ + "\n"
        if self.machination_args is not None:
            str_ += f"\tcmd: machination {' '.join(self.machination_args[1:])}\n"
        str_ += f"\tN machines: {len(self.machines)}\n"
        str_ += f"\t{self.network_delay_millis}\n"
        str_ += f"\t{self.network_pps}\n"
        str_ += f"\tFixed per trace: {self.FIXED_PER_TRACE}\n"

        if self.simul_kwargs:
            str_ += "Simul. args\n"
            for k, v in self.simul_kwargs.items():
                str_ += f"\t{k} : {v}\n"

        if to_log:
            log_multiline(str_)

        return str_

    def _get_machines(self, idx: int | None) -> tuple[list[str], list[str]]:
        idx = idx or self.machine_rng()

        try:
            return self.machines[idx]["client"], self.machines[idx]["server"]
        except IndexError as e:
            raise IndexError(
                f"You provided machine {idx}, however there is only \
                {len(self.machines)} machines available!"
            ) from e

    def _simulate(
        self, trace_path: os.PathLike, machine_idx: int | None = None
    ) -> dict[str, torch.Tensor]:

        client_machines, server_machines = self._get_machines(machine_idx)

        times, dirs, paddings = sim_trace_from_file_advanced(
            str(trace_path),
            client_machines,
            server_machines,
            self.network_delay_millis(),
            self.network_pps(),
            max_padding_frac_client=0,
            max_padding_frac_server=0,
            max_blocking_frac_client=0,
            max_blocking_frac_server=0,
            max_trace_length=self.simul_kwargs.get(
                "max_trace_length", MAX_TRACE_LENGTH
            ),
            events_multiplier=self.simul_kwargs.get(
                "events_multiplier", EVENTS_MULTIPLIER
            ),
            random_state=self.simul_rng(),
        )

        trace_d = parse_trace_to_tensor_dict(times, dirs, paddings, None)

        return trace_d

    @abstractmethod
    def _machination(self, tmpfile_: str, **kwargs) -> None:
        raise NotImplementedError

    def _mlflow_log_params(self) -> dict[str, str]:
        d = {k: str(v) for k, v in self.machination_kwargs.items()}
        d[DEFENCE_TYPE_KW] = self.__class__.__name__.lower()
        d["fixed_per_trace"] = str(self.FIXED_PER_TRACE)

        return d
